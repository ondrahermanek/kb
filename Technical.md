# Tech

## Functional Programming

- https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/
   - `algebraic effects`, `eff`
   
- https://betterprogramming.pub/when-and-when-not-to-use-functional-programming-73dbcb5d0a85
   - `pipe`

- https://link.medium.com/jbCfrKEyLib
   - "make time to spec" - will save from overengineer and bad design
   - "build & deliver fast" - short fb loop
   - "make it pretty" - UX is less forgiving than bugs
   - "when in doubt, copy" - no need to innovate at all costs

## Coding

### Async in C# 10
   - pluralsight [course](https://app.pluralsight.com/library/courses/c-sharp-11-whats-new/table-of-contents)
   - `async`, `await`, `task`, `continuation`, `parallel`, `threads`
   - await creates new task, runs it in separate thread (relieves current), when result is available, returns result and continues in original thread (eg. UI thread), which is good for apps, as no `Dispatcher` code needed
   - `foreach { ... await }` is a big **NO NO** as it basically executes sequentially => use `Task.WhenAll`
   - `Task.ConfigureAwait(true/false)` - `false` is recommended for library usage as it doesn't return to original thread (caller can do themselves). `true` returns to original thread.
   - Task.Factory.StarNew allows to specify more operation params - like ceation options or cancellation token or continuation or child task behavior, parameters without *closure*
   - Locks - Interlocked is faster, less code, but only on ints (algebraics operationns are atomic there)
   - Deadlocks  - don't share lock objects, dont use `string`,  `this`, `typeof()` as lock objects, don't nest locking
   - Cancellations in parallel library - will not start new ones after cancellation is requested, will finish already started (unless stoping implemented internally there)
   - `ThreadLocal<T>` variable scoped to a singlle thread (beware, threads can be shared), has different valuue in diffferent threads
   - `AsyncLocal<T>` variable scoped to a single async context, nested conrext scope creates local copy => keeps outer scope's value
   - Plinq - use `AsParallel`, internally evaluated if parallelizable (independent and safe), `AsOrdered` to force order, `WithCancellation` ... all linq extensions

### Authentication / Authorization
- pluralsigth [course](https://app.pluralsight.com/library/courses/asp-dot-net-core-6-authentication-authorization/transcript)
- **Authentication** is providing a proof about your identity (username + password + MFA, SSO, OAuth, ..). Just like a checking-in into a hotel
- **Authorization** is checking access to resources based on authenticated identity. Just like access via a hotel key card.
-  Cookie authentication - a cookie is generated by server and stored on a client. It contains encrypted data (authentication proof) only server can decrypt and verify. `SameSite` cookie
   - Identity cookie uses `ClaimPrincipal`, with multiple `ClaimsIdentities` (per sign in method/source), with multiple `Claim`s (i.e. the data) 

### c# 11 news
    - raw strings, required init, array pattern match, generic attributes - IValidator, generic math, file access modifier

### EF

- https://medium.com/@amolaher67/ef-core-2-performance-improvement-clear-all-tracked-entities-84d5f36ac02
   - EF core: ChangeTracker.Clear() clears state and saves memory
     
## Architecture

### Clean architecture

- https://github.com/jasontaylordev/CleanArchitecture/blob/main/README-template.md


- ps course (by Renze) about basic patterns and principles
  - clean architecture is designed for system's inhabitants, not architects or machine
    - Presentatio  = UI
    - Domain = business domain (aggregate roots)
    - Appliccation = Abstraction
    - Persistance = interface to data storage
    - Infrastructure = 3rd party dependencies, OS interface
    - Common = library
  - Domain centric
    - usability (domain & use cases) >>> implementation detail
    - Pro: less coupling, DDD, ...
    - Con: requires splid domain vs app
    - onion arch: inner = domain, services, app. services. outer: tests, infra, ui
  - Application layer (business, usecases)
    - sliced to manageable level of complexity
    - handy to implement Inversion of controll - persistence and infra layer to depend on application and domain (orm)
  - commands and queries (cqrs)
    - command - does sth, modifies state, shoul be void
    - query - answers questiinm does not modify state, returns value
    - event sourcing + event store - saving events and replaying them to get the state, update read db. complete audut trail, any-time pitr, replay for debug
  - microservices - granularity up to us, good is by aggregate roots
    - message bus,queues, events
  - tdd = red, green, refactor. acceptance tests (mocked service tests)

 ### Dependency injection (Ps course)
 - testability, loose coupling, inversion of control (of creation)
 - ctor depedency, IserviceCollection to register all services
 - transient = 4each dependency gets new instance (state is thread safe, GC heavy)
 - singleton - 1ce a lafetime of app, GC light, when heavy to construct, mind thread, memory leak prone
 - scoped - lives per scope (i.e. request), not necessary to be thread safe
 - automatic disposing of dependencies, CreateAsyncScope + IAsyncDisposable
 - using ServiceDescriptors, last used from multiple registrations
 or use TryAdd service to avoid replacing by accident
 - services can be Replace, or RemoveAll
 - multipke dependencies resolved as collection IEnubetable<T> - used e.g. for multiple rules
 - code polish - create XYServiceCollectionExtension to move related XY comp. registration to separate file
 - activator utiluties - fw components like Controllers, tag helpers, model binders
 - [FromService] allows to register/resolve dependency in action method params, rather than in controller ctor - GC lighter
 - Scrutor - nuget package, used for assembly scanning (register based on rules) and decorator pattern (extend functionality without modifying current code)
 - Autofac - more powerfull dependency container
 

### Aggregate roots & event sourcing

- https://codeopinion.com/aggregate-root-design-behavior-data/
- https://codeopinion.com/clean-up-your-domain-model-with-event-sourcing/

## Techniques

- https://mtlynch.io/code-review-love/
- https://mtlynch.io/human-code-reviews-1/#what-is-a-code-review
- https://mtlynch.io/human-code-reviews-2/
   - `reviewer`, `reviewee`, `feedback`, `communication`

- https://medium.com/swlh/the-ultimate-engineers-guide-to-code-refactoring-c38372632906
   - `refactoring`
   - When, what, how to refactor. The costs and benefits. Some approaches.

- https://techleadjournal.dev/episodes/89 (https://www.youtube.com/watch?v=ME4UTpKlr0c)
   - `code quality`
   - New lines are liability, not asset. You spend more time reading code than writing it. Code should be sustainable (more than maintainable).

## Sources

- https://buildplease.com/pages/

## Tools

- [Gitbutler](https://gitbutler.com/), [Demo](https://www.youtube.com/watch?v=PWc4meBj4jo&ab_channel=GitButler) - Git client that does lots of stuff automatically
- [EventStore DB](https://www.eventstore.com/eventstoredb) - event native DB, for apps using Event sourcing, Microservices, Event-driven architecture
- [NSwag](https://github.com/RicoSuter/NSwag) - Open API swagger generation tool (replacing swashbuckle)
- [Dev Proxy](https://learn.microsoft.com/en-us/microsoft-cloud/dev/dev-proxy/overview) - [blog](https://devblogs.microsoft.com/dotnet/build-test-resilient-apps-dotnet-dev-proxy/) - tool to help simulate errors, delays, rate limitting
   - similar, but better than [webhook.site](https://webhook.site/)
- [Structurizer](https://docs.structurizr.com/lite/quickstart) - diagram as a code using the [c4 model](https://c4model.com/).

## Articles/videos/

- [Event driven architecture](https://en.wikipedia.org/wiki/Event-driven_architecture) - for loosely coupled systems. Layers: ((((e. producer) e. channel) e. processing engine) | e. driven activity)
