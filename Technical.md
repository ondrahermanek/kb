# Tech

## Functional Programming

- https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/
   - `algebraic effects`, `eff`
   
- https://betterprogramming.pub/when-and-when-not-to-use-functional-programming-73dbcb5d0a85
   - `pipe`

- https://link.medium.com/jbCfrKEyLib
   - "make time to spec" - will save from overengineer and bad design
   - "build & deliver fast" - short fb loop
   - "make it pretty" - UX is less forgiving than bugs
   - "when in doubt, copy" - no need to innovate at all costs

## Coding

### Async in C# 10
   - pluralsight [course](https://app.pluralsight.com/library/courses/c-sharp-11-whats-new/table-of-contents)
   - `async`, `await`, `task`, `continuation`, `parallel`, `threads`
   - await creates new task, runs it in separate thread (relieves current), when result is available, returns result and continues in original thread (eg. UI thread), which is good for apps, as no `Dispatcher` code needed
   - `foreach { ... await }` is a big **NO NO** as it basically executes sequentially => use `Task.WhenAll`
   - `Task.ConfigureAwait(true/false)` - `false` is recommended for library usage as it doesn't return to original thread (caller can do themselves). `true` returns to original thread.
   - Task.Factory.StarNew allows to specify more operation params - like ceation options or cancellation token or continuation or child task behavior, parameters without *closure*
   - Locks - Interlocked is faster, less code, but only on ints (algebraics operationns are atomic there)
   - Deadlocks  - don't share lock objects, dont use `string`,  `this`, `typeof()` as lock objects, don't nest locking
   - Cancellations in parallel library - will not start new ones after cancellation is requested, will finish already started (unless stoping implemented internally there)
   - `ThreadLocal<T>` variable scoped to a singlle thread (beware, threads can be shared), has different valuue in diffferent threads
   - `AsyncLocal<T>` variable scoped to a single async context, nested conrext scope creates local copy => keeps outer scope's value
   - Plinq - use `AsParallel`, internally evaluated if parallelizable (independent and safe), `AsOrdered` to force order, `WithCancellation` ... all linq extensions

### Authentication / Authorization
- pluralsigth [course](https://app.pluralsight.com/library/courses/asp-dot-net-core-6-authentication-authorization/transcript)
- **Authentication** is providing a proof about your identity (username + password + MFA, SSO, OAuth, ..). Just like a checking-in into a hotel
- **Authorization** is checking access to resources based on authenticated identity. Just like access via a hotel key card.
-  Cookie authentication - a cookie is generated by server and stored on a client. It contains encrypted data (authentication proof) only server can decrypt and verify. `SameSite` cookie
   - Identity cookie uses `ClaimPrincipal`, with multiple `ClaimsIdentities` (per sign in method/source), with multiple `Claim`s (i.e. the data) 

### c# 11 news
    - raw strings, required init, array pattern match, generic attributes - IValidator, generic math, file access modifier

### EF

- https://medium.com/@amolaher67/ef-core-2-performance-improvement-clear-all-tracked-entities-84d5f36ac02
   - EF core: ChangeTracker.Clear() clears state and saves memory
     
## Architecture

### Clean architecture

- https://github.com/jasontaylordev/CleanArchitecture/blob/main/README-template.md


- ps course (by Renze) about basic patterns and principles
  - clean architecture is designed for system's inhabitants, not architects or machine
    - Presentatio  = UI
    - Domain = business domain (aggregate roots)
    - Appliccation = Abstraction
    - Persistance = interface to data storage
    - Infrastructure = 3rd party dependencies, OS interface
    - Common = library
  - Domain centric
    - usability (domain & use cases) >>> implementation detail
    - Pro: less coupling, DDD, ...
    - Con: requires splid domain vs app
    - onion arch: inner = domain, services, app. services. outer: tests, infra, ui
  - Application layer (business, usecases)
    - sliced to manageable level of complexity
    - handy to implement Inversion of controll - persistence and infra layer to depend on application and domain (orm)
  - commands and queries (cqrs)
    - command - does sth, modifies state, shoul be void
    - query - answers questiinm does not modify state, returns value
    - event sourcing + event store - saving events and replaying them to get the state, update read db. complete audut trail, any-time pitr, replay for debug
  - microservices - granularity up to us, good is by aggregate roots
    - message bus,queues, events
  - tdd = red, green, refactor. acceptance tests (mocked service tests)
 
  - 
### Aggregate roots & event sourcing

- https://codeopinion.com/aggregate-root-design-behavior-data/
- https://codeopinion.com/clean-up-your-domain-model-with-event-sourcing/

## Techniques

- https://mtlynch.io/code-review-love/
- https://mtlynch.io/human-code-reviews-1/#what-is-a-code-review
- https://mtlynch.io/human-code-reviews-2/
   - `reviewer`, `reviewee`, `feedback`, `communication`

- https://medium.com/swlh/the-ultimate-engineers-guide-to-code-refactoring-c38372632906
   - `refactoring`
   - When, what, how to refactor. The costs and benefits. Some approaches.

- https://techleadjournal.dev/episodes/89 (https://www.youtube.com/watch?v=ME4UTpKlr0c)
   - `code quality`
   - New lines are liability, not asset. You spend more time reading code than writing it. Code should be sustainable (more than maintainable).

## Sources

- https://buildplease.com/pages/
